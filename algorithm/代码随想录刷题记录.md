# 代码随想录刷题记录

## 数组
### 二分查找
**使用二分查找的条件为：**
* 数组有序
* 数组中无重复元素
二分查找的难点在于边界判断，写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right);

[leetcode链接](https://leetcode.cn/problems/binary-search/)

**两种解决方案如下：**
1. 左闭右闭[left, right]
```typescript
function search(nums: number[], target: number): number {
    var left: number = 0;
    var right: number = nums.length - 1;
    while(left <= right){
        var mid:number = left + Math.floor((right-left)/2);
        if(nums[mid] > target){
            right = mid - 1;
        }else if(nums[mid] < target){
            left = mid + 1;
        }else{
            return mid;
        }
    }
    return -1;
};
```
2. 左闭右开[left, right)
```typescript
function search(nums: number[], target: number): number {
    var left: number = 0;
    var right: number = nums.length;
    while(left < right){
        var mid:number = left + Math.floor((right-left)/2);
        if(nums[mid] > target){
            right = mid;
        }else if(nums[mid] < target){
            left = mid + 1;
        }else{
            return mid;
        }
    }
    return -1;
};
```

### 移除元素
因为数组中的元素是连续的，所以数组中的元素不能简单地删除（删除不了），只能覆盖。

[leetcode链接](https://leetcode.cn/problems/remove-element/)

1. 暴力解法

![暴力解法展示](https://tva1.sinaimg.cn/large/008eGmZEly1gntrc7x9tjg30du09m1ky.gif)
```typescript
function removeElement(nums: number[], val: number): number {
    let len = nums.length;
    for(let i = 0;i < len;i++){
        if(nums[i] === val){
            for(let j = i;j < len;j++){
                nums[j] = nums[j+1]
            }
            i--; // 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位
            len--; // 此时数组的大小-1
        }
    }
    return len;
};
```

2. 双指针

![双指针](https://tva1.sinaimg.cn/large/008eGmZEly1gntrds6r59g30du09mnpd.gif)

```javascript
var removeElement = (nums, val) => {
    let slowIndex  = 0;
    for(let fastIndex  = 0;fastIndex  < nums.length;fastIndex++){
        if(nums[fastIndex ] != val){
            nums[slowIndex++] = nums[fastIndex ]
        }
    }
    return slowIndex ;
};
```

3. 双指针优化
避免了需要保留的元素的重复赋值操作。
```javascript
var removeElement = function(nums, val) {
    let left = 0, right = nums.length;
    while (left < right) {
        if (nums[left] === val) {
            nums[left] = nums[right - 1];
            right--;
        } else {
            left++;
        }
    }
    return left;
};
```

### 有序数组的平方
数组其实是有序的， 只不过负数平方之后可能成为最大数了。

那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。

此时可以考虑双指针法了，i指向起始位置，j指向终止位置。

定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。

如果A[i] * A[i] < A[j] * A[j] 那么result[k--] = A[j] * A[j]; 。

如果A[i] * A[i] >= A[j] * A[j] 那么result[k--] = A[i] * A[i]; 

![gif](https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif)

```typescript
function sortedSquares(nums: number[]): number[] {
    let i:number = 0;
    let j:number = nums.length - 1;
    let k:number = j;
    const newNums:number[] = []
    while(i <= j){
        if(nums[i]*nums[i] > nums[j]*nums[j]){
            newNums[k--] = nums[i++]**2;
        }else{
            newNums[k--] = nums[j--]**2;
        }
    }
    return newNums;
};
```